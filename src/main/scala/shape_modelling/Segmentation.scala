package shape_modelling

import java.io.File

import breeze.linalg.DenseVector
import scalismo.geometry._3D
import scalismo.image.DiscreteScalarImage
import scalismo.io.{ActiveShapeModelIO, ImageIO}
import scalismo.numerics.UniformSampler
import scalismo.registration.RigidTransformationSpace
import scalismo.sampling.algorithms.MetropolisHastings
import scalismo.sampling.evaluators.ProductEvaluator
import scalismo.sampling.loggers.AcceptRejectLogger
import scalismo.sampling.proposals.MixtureProposal
import scalismo.sampling.{DistributionEvaluator, ProposalGenerator, TransitionRatio}
import scalismo.statisticalmodel.asm.ActiveShapeModel
import scalismo.ui.ShapeModelView
import scalismo.ui.api.SimpleAPI.ScalismoUI
import shape_modelling.MCMC._

import scala.util.Random

object Segmentation {
  private[this] var ui : ScalismoUI = _

  def main(args: Array[String]) {


    // required to initialize native libraries (VTK, HDF5 ..)
    scalismo.initialize()

    // Your application code goes below here. Below is a dummy application that reads a mesh and displays it

    // create a visualization window
    ui = ScalismoUI()

    val asm = ActiveShapeModelIO.readActiveShapeModel(new File("handedData/femur-asm.h5")).get
    val image = ImageIO.read3DScalarImage[Short](new File("handedData/targets/37.nii")).get.map(_.toFloat)

    ui.show(asm.statisticalModel, "model")
    ui.show(image, "image")

    //runPoseFitting(asm, image)
    runShapeFitting(asm, image)
  }

  def runPoseFitting(asm: ActiveShapeModel, image: DiscreteScalarImage[_3D, Float]): Unit = {
    val samples = UniformSampler(image.domain.boundingBox, 1000).sample.map(i => i._1)

    System.out.println("Running pose fitting...")

    val posteriorEvaluator = ProductEvaluator(MCMC.ShapePriorEvaluator(asm.statisticalModel), ProximityEvaluator(asm.statisticalModel, samples))

    val poseGenerator = MixtureProposal.fromProposalsWithTransition((0.2, RotationUpdateProposal(0.1f)), (0.2, TranslationUpdateProposal(0.1f)))(rnd = new Random())
    val chain = MetropolisHastings(poseGenerator, posteriorEvaluator)(new Random())

    val initialParameters = ShapeParameters(DenseVector.zeros[Float](3), DenseVector.zeros[Float](3), DenseVector.zeros[Float](asm.statisticalModel.rank))
    val mhIt = chain.iterator(initialParameters)

    val rigidTransSpace = RigidTransformationSpace[_3D]()
    var bestCoefs : ShapeParameters = null
    var bestProb : Double = 0
    val samplingIterator = for(theta <- mhIt) yield {

      val prob = posteriorEvaluator.logValue(theta)
      System.out.println(prob)

      if (prob > bestProb) {
        System.out.println("Found!!")

        ui.setCoefficientsOf("model", theta.modelCoefficients)
        val rigidtrans = rigidTransSpace.transformForParameters(DenseVector.vertcat(theta.translationParameters, theta.rotationParameters))


        // internal scalismo ui code for efficiency reasons, to update the rigid position of the model (no need to understand the details of this)
        val smInstance = ui.frame.scene.find[ShapeModelView](si => si.name == "model").head.instances.head
        smInstance.rigidTransformation = Some(rigidtrans)

        bestCoefs = theta
        bestProb = prob
      }

    }

    samplingIterator.take(100).toIndexedSeq
  }

  def runShapeFitting(asm: ActiveShapeModel, image: DiscreteScalarImage[_3D, Float]): Unit = {

    val logger = new AcceptRejectLogger[ShapeParameters] {
      private var accepted = 0f
      private var all = 0f

      override def accept(current: ShapeParameters, sample: ShapeParameters, generator: ProposalGenerator[ShapeParameters], evaluator: DistributionEvaluator[ShapeParameters]): Unit = {
        accepted += 1
        all += 1

        val ratio = accepted / all
        println(s"Accepted proposal generated by $generator (probability ${evaluator.logValue(sample)}) : $ratio")
      }

      override def reject(current: ShapeParameters, sample: ShapeParameters, generator: ProposalGenerator[ShapeParameters], evaluator: DistributionEvaluator[ShapeParameters]): Unit = {
        all += 1
        val ratio = accepted / all
        println(s"Rejected proposal generated by $generator (probability ${evaluator.logValue(sample)}) : $ratio")
      }
    }

    val samples = UniformSampler(image.domain.boundingBox, 1000).sample.map(i => i._1)

    val prepImg = asm.preprocessor(image)

    System.out.println("Running shape fitting...")

    val posteriorEvaluator = ProductEvaluator(MCMC.ShapePriorEvaluator(asm.statisticalModel), IntensityBasedLikeliHoodEvaluator(asm, prepImg))

    // Deviations should match deviations of model
    val poseGenerator =  MixtureProposal.fromProposalsWithTransition((0.7, ShapeUpdateProposal(asm.statisticalModel.rank, 0.1f)), (0.2, ShapeUpdateProposal(asm.statisticalModel.rank, 0.2f)), (0.1, ShapeUpdateProposal(asm.statisticalModel.rank, 0.3f)))(rnd=new Random())

    val chain = MetropolisHastings(poseGenerator, posteriorEvaluator, logger)(new Random())

    val initialParameters = ShapeParameters(DenseVector.zeros[Float](3), DenseVector.zeros[Float](3), DenseVector.zeros[Float](asm.statisticalModel.rank))
    val mhIt = chain.iterator(initialParameters)

    val rigidTransSpace = RigidTransformationSpace[_3D]()
    var bestCoefs : ShapeParameters = null
    var bestProb : Double = Double.NegativeInfinity
    var lastCoefs = initialParameters
    val samplingIterator = for(theta <- mhIt) yield {
      if (lastCoefs != theta) {
        ui.setCoefficientsOf("model", theta.modelCoefficients)
      }
    }

    samplingIterator.drop(500).take(4000).toIndexedSeq
  }
}
