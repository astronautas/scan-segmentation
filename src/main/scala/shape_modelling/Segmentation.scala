package shape_modelling

import java.io.File

import breeze.linalg.{DenseMatrix, DenseVector, reshape}
import breeze.numerics.{exp, log, sqrt}
import scalismo.geometry._3D
import scalismo.image.DiscreteScalarImage
import scalismo.io.{ActiveShapeModelIO, ImageIO}
import scalismo.numerics.UniformSampler
import scalismo.registration.RigidTransformationSpace
import scalismo.sampling.algorithms.MetropolisHastings
import scalismo.sampling.evaluators.ProductEvaluator
import scalismo.sampling.loggers.AcceptRejectLogger
import scalismo.sampling.proposals.MixtureProposal
import scalismo.sampling.{DistributionEvaluator, ProposalGenerator, TransitionRatio}
import scalismo.statisticalmodel.asm.{ActiveShapeModel, PreprocessedImage}
import scalismo.ui.ShapeModelView
import scalismo.ui.api.SimpleAPI.ScalismoUI
import shape_modelling.MCMC._

import scala.util.Random

object Segmentation {
  private[this] var ui : ScalismoUI = _

  def main(args: Array[String]) {


    // required to initialize native libraries (VTK, HDF5 ..)
    scalismo.initialize()

    // Your application code goes below here. Below is a dummy application that reads a mesh and displays it

    // create a visualization window
    //ui = ScalismoUI()

    val asm = ActiveShapeModelIO.readActiveShapeModel(new File("handedData/femur-asm.h5")).get
    val image = ImageIO.read3DScalarImage[Short](new File("handedData/targets/37.nii")).get.map(_.toFloat)

    //ui.show(asm.statisticalModel, "model")
    //ui.show(image, "image")

    // PREPROCESSING
    System.out.println("Preprocessing...")
    val prepImg: PreprocessedImage = asm.preprocessor(image)

    // FITTING
    //runPoseFitting(asm, image)
    var coeffs = ShapeParameters(DenseVector.zeros[Float](3), DenseVector.zeros[Float](3), asm.statisticalModel.coefficients(asm.statisticalModel.mean))

    0 until coeffs.modelCoefficients.length foreach(i => {
      coeffs = runShapeFittingForComponents(asm, prepImg, coeffs, i)
    })

    coeffs = runShapeFitting(asm, prepImg, coeffs)
  }

  def runPoseFitting(asm: ActiveShapeModel, image: DiscreteScalarImage[_3D, Float]): Unit = {
    val samples = UniformSampler(image.domain.boundingBox, 1000).sample.map(i => i._1)

    System.out.println("Running pose fitting...")

    val posteriorEvaluator = ProductEvaluator(MCMC.ShapePriorEvaluator(asm.statisticalModel), ProximityEvaluator(asm.statisticalModel, samples))

    val poseGenerator = MixtureProposal.fromProposalsWithTransition((0.2, RotationUpdateProposal(0.1f)), (0.2, TranslationUpdateProposal(0.1f)))(rnd = new Random())
    val chain = MetropolisHastings(poseGenerator, posteriorEvaluator)(new Random())

    val initialParameters = ShapeParameters(DenseVector.zeros[Float](3), DenseVector.zeros[Float](3), DenseVector.zeros[Float](asm.statisticalModel.rank))
    val mhIt = chain.iterator(initialParameters)

    val rigidTransSpace = RigidTransformationSpace[_3D]()
    var bestCoefs : ShapeParameters = null
    var bestProb : Double = 0
    val samplingIterator = for(theta <- mhIt) yield {

      val prob = posteriorEvaluator.logValue(theta)
      System.out.println(prob)

      if (prob > bestProb) {
        System.out.println("Found!!")

        ui.setCoefficientsOf("model", theta.modelCoefficients)
        val rigidtrans = rigidTransSpace.transformForParameters(DenseVector.vertcat(theta.translationParameters, theta.rotationParameters))


        // internal scalismo ui code for efficiency reasons, to update the rigid position of the model (no need to understand the details of this)
        val smInstance = ui.frame.scene.find[ShapeModelView](si => si.name == "model").head.instances.head
        smInstance.rigidTransformation = Some(rigidtrans)

        bestCoefs = theta
        bestProb = prob
      }

    }

    samplingIterator.take(40).toIndexedSeq
  }

  def runShapeFittingForComponents(asm: ActiveShapeModel, prepImg : PreprocessedImage, initialParameters : ShapeParameters, tillComponentIndex: Int): ShapeParameters = {
    val logger = new AcceptRejectLogger[ShapeParameters] {
      private var accepted = 0f
      private var all = 0f

      override def accept(current: ShapeParameters, sample: ShapeParameters, generator: ProposalGenerator[ShapeParameters], evaluator: DistributionEvaluator[ShapeParameters]): Unit = {
        accepted += 1
        all += 1

        val ratio = accepted / all
        println(s"Accepted proposal generated by $generator (probability ${evaluator.logValue(sample)}) : $ratio")
      }

      override def reject(current: ShapeParameters, sample: ShapeParameters, generator: ProposalGenerator[ShapeParameters], evaluator: DistributionEvaluator[ShapeParameters]): Unit = {
        all += 1
        val ratio = accepted / all
        println(s"Rejected proposal generated by $generator (probability ${evaluator.logValue(sample)}) : $ratio")
      }
    }


    println("Running runShapeFittingForFirstComponents till..." + tillComponentIndex)

    val posteriorEvaluator = ProductEvaluator(MCMC.ShapePriorEvaluator(asm.statisticalModel), IntensityBasedLikeliHoodEvaluator(asm, prepImg))

    // Deviations should match deviations of model
    val poseGenerator =  MixtureProposal.fromProposalsWithTransition((0.8, ShapeUpdateProposalFirstComponents(asm.statisticalModel.rank, 0.09f, tillComponentIndex)), (0.2, ShapeUpdateProposalFirstComponents(asm.statisticalModel.rank, 0.2f, tillComponentIndex)))(rnd=new Random())

    val chain = MetropolisHastings(poseGenerator, posteriorEvaluator, logger)(new Random())

    val mhIt = chain.iterator(initialParameters)

    val samplingIterator = for(theta <- mhIt) yield {
      theta
    }

    // TODO - what is burn in factor, how to get rid of it (thats why drop is here)
    // http://background.uchicago.edu/~whu/Courses/Ast321_11/Projects/mcmc_helsby.pdf
    val take = 200
    val samples = samplingIterator.drop(take / 12).take(take)
    val bestSample = samples.maxBy(posteriorEvaluator.logValue)

    bestSample
  }

  def runShapeFitting(asm: ActiveShapeModel, prepImg : PreprocessedImage, initialParameters : ShapeParameters): ShapeParameters = {
    val logger = new AcceptRejectLogger[ShapeParameters] {
      private var accepted = 0f
      private var all = 0f

      override def accept(current: ShapeParameters, sample: ShapeParameters, generator: ProposalGenerator[ShapeParameters], evaluator: DistributionEvaluator[ShapeParameters]): Unit = {
        accepted += 1
        all += 1

        val ratio = accepted / all
        println(s"Accepted proposal generated by $generator (probability ${evaluator.logValue(sample)}) : $ratio")
      }

      override def reject(current: ShapeParameters, sample: ShapeParameters, generator: ProposalGenerator[ShapeParameters], evaluator: DistributionEvaluator[ShapeParameters]): Unit = {
        all += 1
        val ratio = accepted / all
        println(s"Rejected proposal generated by $generator (probability ${evaluator.logValue(sample)}) : $ratio")
      }
    }

    System.out.println("Running runShapeFitting...")

    val posteriorEvaluator = ProductEvaluator(MCMC.ShapePriorEvaluator(asm.statisticalModel), IntensityBasedLikeliHoodEvaluator(asm, prepImg))

    // Deviations should match deviations of model
    val poseGenerator =  MixtureProposal.fromProposalsWithTransition((0.7, ShapeUpdateProposal(asm.statisticalModel.rank, 0.05f)), (0.3, ShapeUpdateProposal(asm.statisticalModel.rank, 1f)))(rnd=new Random())

    val chain = MetropolisHastings(poseGenerator, posteriorEvaluator, logger)(new Random())

    val mhIt = chain.iterator(initialParameters)

    val samplingIterator = for(theta <- mhIt) yield {
      theta
    }

    val take = 200
    val samples = samplingIterator.drop(take / 12).take(take)
    val bestSample = samples.maxBy(posteriorEvaluator.logValue)

    // TODO - what is burn in factor, how to get rid of it (thats why drop is here)
    // http://background.uchicago.edu/~whu/Courses/Ast321_11/Projects/mcmc_helsby.pdf
    samplingIterator.take(2000).toIndexedSeq

    bestSample
  }

  // Adaptive covariance
  var learn_scale = 0.5
  var sampleDiscard = 200
  var adaptScale = false
  var sampleLag = 20
  var meanEst = DenseVector.ones(25)
  var covEst = 0.05f * DenseMatrix.eye[Float](25)
  var globalScale = Math.pow(2.38, 2) / 25
  var accStar = 0.234
  def adapt(iteration : Int, stepOutput : ShapeParameters, logAcceptance : Double) : Unit = {

    if (iteration > sampleDiscard) {
      learn_scale = 1.0 / sqrt(iteration - sampleDiscard + 1.0)

      if (adaptScale) {
        scaleAdapt(learn_scale, stepOutput, logAcceptance)
      }

      if (iteration % sampleLag == 0) {
        meanAndCovAdapt(learn_scale, stepOutput)
      }
    }
  }

  def scaleAdapt(learn_scale : Double, step_output : ShapeParameters, logAcceptance : Double) : Unit = {
    // implement this
    //        self.globalscale = exp(log(self.globalscale) + learn_scale * (exp(step_output.log_ratio) - self.accstar))
    globalScale = exp(log(globalScale) + learn_scale + (exp(logAcceptance) - accStar))
  }

  //        current_1d=reshape(self.current_sample_object.samples, (self.distribution.dimension,))
  //        difference=current_1d - self.mean_est
  //        self.cov_est += learn_scale * (outer(difference, difference) - self.cov_est)
  //        self.mean_est += learn_scale * (current_1d - self.mean_est)
  //        #print "mean estimate: ", self.mean_est
  def meanAndCovAdapt(learnScale : Double, stepOutput : ShapeParameters) : Unit = {
    // implement this
    var current = stepOutput.modelCoefficients

    var diff = DenseVector(current - meanEst)

    meanEst += learnScale * diff
    covEst += learnScale * (DenseMatrix(diff.t * diff) - covEst)
  }
}
